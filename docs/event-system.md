# Event System Architecture

## Overview

The event system in PlayTUI follows a multi-layered architecture that handles everything from raw terminal events to high-level component actions. The system is designed to clearly separate UI updates from state changes while preventing event loops and maintaining component independence.

## Event-Action Flow

### 1. Core Flow Pattern
```
Initial Event -> Action -> (Maybe) New Event -> (Maybe) Follow-up Action
```

### 2. Action Types and Their Behavior

1. **UI-Only Actions (Refresh)**
   - Generated by navigation events (arrow keys)
   - Do not generate new events (terminal actions)
   - Only update the UI
   - Prevent cascading event loops
   ```rust
   // Example: Library browser navigation
   KeyEvent::Down => {
       state.navigate_down()?;
       Some(Action::Refresh)  // Terminal action, just updates UI
   }
   ```

2. **State-Changing Actions**
   - Generated by functionality events (Enter, space, etc.)
   - Generate new events for state propagation
   - Allow other components to react to state changes
   ```rust
   // Example: Control button activation
   KeyEvent::Enter => {
       Some(Action::Player(PlayerAction::Play))  // Generates new events
   }
   ```

### 3. Event Processing Chain

1. **Raw Event Capture**
```rust
match event::read()? {
    event @ CrosstermEvent::Key(key) => {
        if let Some(key_event) = map_key_event(key.code, key.modifiers) {
            app.handle_event(Event::Key(key_event))
        }
    }
}
```

2. **Event Types**
```rust
enum Event {
    Key(KeyEvent),
    Mouse(MouseEvent),
    Navigation(NavigationEvent),
    System(SystemEvent),
}
```

3. **Action Generation**
```rust
enum Action {
    // UI-Only Actions
    Refresh,                // Terminal action for UI updates
    
    // State-Changing Actions
    Player(PlayerAction),   // Generates new events
    UI(UIAction),          // May generate new events
    App(AppAction),        // System-level state changes
    
    // Navigation Actions
    NavigateLeft,
    NavigateRight,
    Select,
    Back,
}
```

### 4. Action Processing
```rust
// In ComponentManager
pub fn update_components(&mut self, action: Action) {
    let mut pending_actions = vec![action];
    let mut processed_actions = Vec::new();

    while let Some(current_action) = pending_actions.pop() {
        // Prevent duplicate processing
        if processed_actions.contains(&current_action) {
            continue;
        }
        processed_actions.push(current_action.clone());

        // Convert action to event if needed
        if let Some(event) = self.convert_action_to_event(&current_action) {
            // Process through components
            for component in &mut self.components {
                if let Ok(Some(follow_up)) = component.handle_event(&event) {
                    // Only propagate non-Refresh actions
                    if !matches!(follow_up, Action::Refresh) {
                        pending_actions.push(follow_up);
                    }
                }
            }
        }
    }
}
```

## Focus Management

### Focus Rules

1. **Global Navigation**
   - Tab/BackTab events always available
   - Changes focus between frames
   - Focus cycles in predefined order
   - Visual feedback for current focus

2. **Frame-Specific Controls**
   - Arrow keys and Enter only work in focused frame
   - Each frame handles events differently:
     * Library Browser: Directory navigation
     * Play Controls: Button navigation
     * Volume Control: Value adjustment

3. **Global Hotkeys**
   - Available regardless of focus
   - Examples: quit, pause/play, etc.

### Focus Implementation
```rust
impl FocusManager {
    pub fn should_process_event(&self, event: &Event, component_name: &str) -> bool {
        match event {
            // Global events always processed
            Event::Key(KeyEvent::Tab) |
            Event::Key(KeyEvent::Quit) => true,
            
            // Frame-specific events require focus
            Event::Key(KeyEvent::Enter) |
            Event::Key(KeyEvent::Left) |
            Event::Key(KeyEvent::Right) |
            Event::Key(KeyEvent::Up) |
            Event::Key(KeyEvent::Down) => {
                component_name == self.current_focus()
            },
            // ...
        }
    }
}
```

## Component Guidelines

### 1. Event Handling
```rust
fn handle_event(&mut self, event: &Event) -> EventResult<Option<Action>> {
    if !self.focused() {
        return Ok(None);
    }

    match event {
        // Navigation events generate Refresh
        Event::Key(KeyEvent::Left) => {
            self.navigate_left()?;
            Ok(Some(Action::Refresh))
        },
        
        // Functional events generate state changes
        Event::Key(KeyEvent::Enter) => {
            Ok(Some(Action::Player(PlayerAction::Play)))
        },
        
        // Global events handled regardless of focus
        Event::Key(KeyEvent::Quit) => {
            Ok(Some(Action::App(AppAction::Quit)))
        },
    }
}
```

### 2. Action Generation Rules
- Return Action::Refresh for UI-only updates
- Return state-changing actions for functional changes
- Consider action propagation needs
- Prevent unnecessary event generation

### 3. Focus Management
- Check focus before handling frame-specific events
- Update visual state based on focus
- Handle global events regardless of focus

## Testing

### Event Flow Testing
```rust
#[test]
fn test_refresh_action_handling() {
    let mut component = MyComponent::new();
    
    // Navigation should generate Refresh
    let result = component.handle_event(&Event::Key(KeyEvent::Down));
    assert_eq!(result.unwrap(), Some(Action::Refresh));
    
    // Enter should generate state change
    let result = component.handle_event(&Event::Key(KeyEvent::Enter));
    assert_eq!(result.unwrap(), Some(Action::Player(PlayerAction::Play)));
}
```

### Focus Testing
```rust
#[test]
fn test_focus_rules() {
    let mut component = MyComponent::new();
    
    // Unfocused: ignore navigation
    component.set_focused(false);
    let result = component.handle_event(&Event::Key(KeyEvent::Down));
    assert_eq!(result.unwrap(), None);
    
    // Focused: handle navigation
    component.set_focused(true);
    let result = component.handle_event(&Event::Key(KeyEvent::Down));
    assert_eq!(result.unwrap(), Some(Action::Refresh));
}
```

## Common Issues and Solutions

1. **Event Loops**
   - Use Action::Refresh for UI-only updates
   - Don't generate new events from Refresh actions
   - Track processed actions to prevent duplicates

2. **State Propagation**
   - Use state-changing actions for functional changes
   - Allow these actions to generate new events
   - Consider component dependencies

3. **Focus Management**
   - Verify focus before handling frame-specific events
   - Maintain clear focus indicators
   - Test focus-dependent behavior

4. **Action Processing**
   - Separate UI updates from state changes
   - Track processed actions
   - Consider action propagation needs
